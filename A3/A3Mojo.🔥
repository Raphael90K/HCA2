from python import Python, PythonObject
import sys
from fft import fft
from tensor import Tensor
from complex import ComplexFloat64
from time import now
from tensor import TensorShape
from algorithm import parallelize
from os import Atomic


struct ParallelFft(Stringable):
    var sums: Tensor[DType.float64]
    var size: Int32
    var avg_amp: Tensor[DType.float64]

    var audio_data: List[ComplexFloat64]
    var sample_rate: Float64
    var block_size: Int32
    var offset: Int32
    var num_blocks: Int
    var num_samples: Int32

    var freq_bins: PythonObject

    fn __init__(inout self, owned audio_data: List[ComplexFloat64], sample_rate: Float64, block_size: Int32, offset: Int32) raises:
        var threading = Python.import_module("multiprocessing")
        self.block_size = block_size
        self.size = (self.block_size // 2)

        self.sums = Tensor[DType.float64](self.block_size // 2)

        self.avg_amp = Tensor[DType.float64](self.size)

        self.audio_data = audio_data^
        self.sample_rate = sample_rate

        self.offset = offset

        self.num_samples = len(self.audio_data)
        self.num_blocks = int((self.num_samples - self.block_size) / offset)
        self.freq_bins = PythonObject()

    fn __str__(self) -> String:
        var s: String = "["
        for i in range(self.size):
            s += String(self.sums[i])
            s += ","
        s += "]"
        return s

    fn calc_avg(inout self):
        var blocks = Float64(self.num_blocks)
        for i in range(self.size):
            self.avg_amp[i] = self.sums[i] / blocks

    fn analyze_frequency_blocks(inout self) raises:

        @parameter
        fn calc_loop(block_num: Int):
            var start_index = block_num * self.offset
            var end_index = start_index + self.block_size
            var block = self.get_audio_block(start_index,end_index)
            var fft_result = fft(block)
            self.add_amplitudes(fft_result)
            
            
        parallelize[calc_loop](self.num_blocks)

    fn get_frequencies(inout self) raises:
        var np = Python.import_module("numpy")
        var inverse_sample_rate = 1 / self.sample_rate
        self.freq_bins = np.fft.fftfreq(
            PythonObject(self.block_size), PythonObject(inverse_sample_rate)
        )

    fn apply_threshold(inout self, threshold: Int32) raises:
        for i in range(self.size):
            if self.avg_amp[i] > threshold.cast[DType.float64]():
                print("Freq: ", self.freq_bins[i], " : ", self.avg_amp[i])

    fn get_audio_block(borrowed self, start: Int32, end: Int32) -> List[ComplexFloat64]:
        var result = List[ComplexFloat64]()
        for i in range(start, end):
            result.append(self.audio_data[i])
        return result

    fn add_amplitudes(inout self, fft_result: List[ComplexFloat64]):
        
        for i in range(self.size):
            if i >= len(fft_result):
                break
            self.sums[i] += fft_result[i].norm()
           
    
fn ndarray_to_complexlist(input: PythonObject) raises -> List[ComplexFloat64]:
    var input_length: Float64 = int(len(input))
    var output: List[ComplexFloat64] = List[ComplexFloat64]()
    for i in range[Float64](input_length):
        output.append(ComplexFloat64(input[i].to_float64(), 0))
    return output


fn main() raises:
    Python.add_to_path("./utils/")

    var read_wave_file = Python.import_module("readwav")
    var input = read_wave_file.read_wave_file("./Audios/output.wav")
    var sample_rate = input[0].to_float64()
    var data_input = input[1]
    var data: List[ComplexFloat64] = ndarray_to_complexlist(data_input)
    var amp = ParallelFft(data^, sample_rate, 256, 10)

    var start = now()
    amp.analyze_frequency_blocks()
    amp.get_frequencies()
    amp.calc_avg()
    amp.apply_threshold(1000000)
    var end = now()
    print("Dauer (sek): ", (end - start) / 1_000_000_000)
